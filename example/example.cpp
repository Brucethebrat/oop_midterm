/* Alphar: 2020.04.19 */

#include <stdio.h>
#include <stdlib.h>
#include <SDL.h> // Using SDL
#include "SDL2_gfxPrimitives.h" // Using SDL2_gfx
#include "SDL_image.h"  // Using SDL2 image extension library 

//Screen dimension constants
const int WIDTH = 750;
const int HEIGHT = 500;
const int CH01_FRAME = 16;

const int VELOCITY = 5;
const int CH01_WIDTH = 50;
const int CH01_HEIGHT = 100;

//Initialize the velocity, position and direction
int CH01_VELX = 0;
int CH01_VELY = 0;
int CH01_POSX = 0;//WIDTH / 2;
int CH01_POSY = 0;//HEIGHT / 2;
int DIRECTION = 0;	//0: face downward, 1: face left, 2: face right, 3: face upward

//when true, timer run, when false, timer stop, used in handle event, when moving: true, stop: false
bool TIMER_SWITCH = false;


/*
struct ImageData
{
	char path[100];
	SDL_Texture *texture;
	int width;
	int height;
};
*/

struct ImageData
{
	char path[100];
	SDL_Texture *texture;
	int width;
	int height;
	int num;
	int wn;
	int hn;
};

int initSDL(); // Starts up SDL and creates window
void closeSDL(); // Frees media and shuts down SDL

//ImageData loadTexture(char *path, bool ckEnable, Uint8 r, Uint8 g, Uint8 b);
ImageData loadTexture(char *path, int num, int hn, int wn, bool ckEnable, Uint8 r, Uint8 g, Uint8 b);
//void imgRender(SDL_Renderer *renderer, ImageData img, int posX, int posY);
void imgRender(SDL_Renderer *renderer, ImageData img, int posX, int posY, int frame);
Uint32 aniAction(Uint32 interval, void* param); // Timer callback function
void handleEvent(SDL_Event& e);
void move();


SDL_Window *window = NULL; // The window we'll be rendering to
SDL_Renderer *renderer = NULL; // The window renderer

// Current displayed texture
SDL_Texture *bkTexture = NULL;
SDL_Texture *pikaTexture = NULL;
SDL_Texture *spTexture = NULL;


int initSDL()
{
	// Initialize SDL	
	if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_TIMER) != 0)
	{
		// Error Handling		
		printf("SDL_Init failed: %s\n", SDL_GetError());
		return 1;
	}

	// Create window	
	// SDL_WINDOWPOS_UNDEFINED: Used to indicate that you don't care what the window position is.
	window = SDL_CreateWindow("OOP SDL Tutorial", 50, 50, WIDTH, HEIGHT, SDL_WINDOW_SHOWN);
	if (window == NULL)
	{
		printf("SDL_CreateWindow failed: %s\n", SDL_GetError());
		SDL_Quit();
		return 2;
	}

	// Initialize PNG loading	
	int imgFlags = IMG_INIT_PNG;
	if (!(IMG_Init(imgFlags) & imgFlags))
	{
		printf("SDL_image failed: %s\n", IMG_GetError());
		return 3;
	}

	// Create renderer	
	// VSync allows the rendering to update at the same time as when your monitor updates during vertical refresh.
	// For this tutorial it will make sure the animation doesn't run too fast. 
	// Most monitors run at about 60 frames per second and that's the assumption we're making here. 
	// If you have a different monitor refresh rate, that would explain why the animation is running too fast or slow.
	renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC);
	if (renderer == NULL)
	{
		SDL_DestroyWindow(window);
		printf("SDL_CreateRenderer failed: %s\n", SDL_GetError());
		SDL_Quit();
		return 3;
	}

	return 0;
}


void closeSDL()
{
	// Free loaded image
	SDL_DestroyTexture(bkTexture);
	SDL_DestroyTexture(pikaTexture);

	// Destroy renderer	
	// Destroy window	
	// Quit Image subsystem
	// Quit SDL subsystems
	SDL_DestroyRenderer(renderer);
	SDL_DestroyWindow(window);
	IMG_Quit();
	SDL_Quit();
}


// ImageData loadTexture(char *path, bool ckEnable, Uint8 r, Uint8 g, Uint8 b)
ImageData loadTexture(char *path, int num, int hn, int wn, bool ckEnable, Uint8 r, Uint8 g, Uint8 b)
{
	ImageData img;


	//Load image at specified path
	SDL_Surface* loadedSurface = IMG_Load(path);
	if (loadedSurface == NULL)
	{
		printf("IMG_Load failed: %s\n", IMG_GetError());
	}
	else
	{
		// Set the color key (transparent pixel) in a surface.
		// https://wiki.libsdl.org/SDL_SetColorKey
		// The color key defines a pixel value that will be treated as transparent in a blit. 
		// It is a pixel of the format used by the surface, as generated by SDL_MapRGB().
		// Use SDL_MapRGB() to map an RGB triple to an opaque pixel value for a given pixel format.
		// https://wiki.libsdl.org/SDL_MapRGB
		SDL_SetColorKey(loadedSurface, ckEnable, SDL_MapRGB(loadedSurface->format, r, g, b));

		// Create texture from surface pixels
		img.texture = SDL_CreateTextureFromSurface(renderer, loadedSurface);
		if (img.texture == NULL)
		{
			printf("SDL_CreateTextureFromSurface failed: %s\n", SDL_GetError());
		}

		/******************************************************************/
		//Get image dimensions and information
		img.width = loadedSurface->w;
		img.height = loadedSurface->h;
		img.num = num;
		img.wn = wn;
		img.hn = hn;
		/******************************************************************/

		// Get rid of old loaded surface
		SDL_FreeSurface(loadedSurface);
	}

	//return newTexture;
	return img;
}

/*
void imgRender(SDL_Renderer *renderer, ImageData img, int posX, int posY)
{
	SDL_Rect r;
	r.x = posX;
	r.y = posY;
	r.w = img.width;
	r.h = img.height;
	SDL_RenderCopy(renderer, img.texture, NULL, &r);
}
*/

void imgRender(SDL_Renderer *renderer, ImageData img, int posX, int posY, int frame)
{
	int wc = frame % img.wn;
	int hc = frame / img.wn;
	
	SDL_Rect src, dst;
	src.x = img.width / img.wn * wc;
	src.y = img.height / img.hn * hc;
	src.w = img.width / img.wn;
	src.h = img.height / img.hn;
	dst.x = posX;
	dst.y = posY;
	dst.w = src.w;
	dst.h = src.h;

	SDL_RenderCopy(renderer, img.texture, &src, &dst);
}


Uint32 aniAction(Uint32 interval, void *param)
{
	int *index = (int *)param;
	printf("switch in timer = %d\n", TIMER_SWITCH);
	if (TIMER_SWITCH) {
		//index[1] = (index[1] + 1) % PFRAME;
		//index[2] = (index[2] + 1) % SFRAME;
		index[2] = (index[2] + 1) % (CH01_FRAME / 4) + DIRECTION * 4;
		printf("index[2] = %d", index[2]);
		printf("direction = %d", DIRECTION);

		return interval;
	}

	else {
		index[2] = 0 + DIRECTION * 4;
		return interval;
	}	
}


void handleEvent(SDL_Event& e)
{
	/* The method for "Debunce"(反彈跳時間) */

	// If a key was pressed
	// repeat: non-zero if this is a key repeat
	// https://wiki.libsdl.org/SDL_KeyboardEvent
	//if (e.type == SDL_KEYDOWN)
	if (e.type == SDL_KEYDOWN && e.key.repeat == 0)
	{
		
		//Adjust the velocity
		switch (e.key.keysym.sym)
		{
			case SDLK_UP:
				//if ((CH01_POSY <= 0) || (CH01_POSY + CH01_HEIGHT >= HEIGHT)) //53 是CH01的實際高度，留一點空間在CH01與底部之間
				//	TIMER_SWITCH = false; break;
				TIMER_SWITCH = true;
				CH01_VELY -= VELOCITY; 
				DIRECTION = 3;
				//printf("uping SWITCH = %d\n", TIMER_SWITCH);
				break; 
			case SDLK_DOWN: 
				//if ((CH01_POSY <= 0) || (CH01_POSY + CH01_HEIGHT >= HEIGHT)) //53 是CH01的實際高度，留一點空間在CH01與底部之間
				//	TIMER_SWITCH = false; break;
				TIMER_SWITCH = true;
				CH01_VELY += VELOCITY;
				DIRECTION = 0;
				break;
			case SDLK_LEFT:
				TIMER_SWITCH = true;
				CH01_VELX -= VELOCITY; 
				DIRECTION = 1;
				break;
			case SDLK_RIGHT:
				TIMER_SWITCH = true;
				CH01_VELX += VELOCITY; 
				DIRECTION = 2;
				break;
		}
	}
	//If a key was released
	//else if (e.type == SDL_KEYUP)
	else if (e.type == SDL_KEYUP && e.key.repeat == 0)
	{
		//Adjust the velocity
		switch (e.key.keysym.sym)
		{
			case SDLK_UP: TIMER_SWITCH = false; CH01_VELY += VELOCITY; break;
			case SDLK_DOWN: TIMER_SWITCH = false; CH01_VELY -= VELOCITY; break;
			case SDLK_LEFT: TIMER_SWITCH = false; CH01_VELX += VELOCITY; break;
			case SDLK_RIGHT: TIMER_SWITCH = false; CH01_VELX -= VELOCITY; break;
		}
	}
}


void move()
{
	//Move the dot left or right
	CH01_POSX += CH01_VELX;

	//If the dot went too far to the left or right
	if ((CH01_POSX <= 0) || (CH01_POSX + CH01_WIDTH >= WIDTH))//2 是為了留一點空間給左邊的牆壁
	{
		//Move back
		CH01_POSX -= CH01_VELX;
	}

	//Move the dot up or down
	CH01_POSY += CH01_VELY;

	//If the dot went too far up or down
	if ((CH01_POSY <= 0) || (CH01_POSY + CH01_HEIGHT >= HEIGHT)) //53 是CH01的實際高度，留一點空間在CH01與底部之間
	{
		//Move back
		CH01_POSY -= CH01_VELY;
	}
}


// When using SDL, you have to use "int main(int argc, char* args[])"
// int main() and void main() are not allowed
int main(int argc, char* args[])
{
	// The working directory is where the vcxproj file is located.
	/*
	char imgPath1[100] = "../images/sp.png";
	char imgPath2[100] = "../images/rob.png";
		
	char kissPath[100] = "../images/kiss.png";
	char piestarPath[100] = "../images/piestar.png";	
	char spongePath[100] = "../images/spongebob.png";
	*/
	char imgPath2[100] = "../images/rob.png";

	char ch01Path[100] = "../images/character01_pictures_37x53.png";
	int animationIndex[3] = { 0,0,0 };
	

	ImageData sp, rob;
	ImageData ch01;//, sponge, kiss, pie;
	//ImageData ku[FRAME];

	// Start up SDL and create window
	if (initSDL())
	{
		printf("Failed to initialize SDL!\n");
		return -1;
	}
	/*
	sp = loadTexture(imgPath1, 1, 1, 1, true, 0xFF, 0xFF, 0xFF);
	rob = loadTexture(imgPath2, 1, 1, 1, false, 0xFF, 0xFF, 0xFF);
	
	kiss = loadTexture(kissPath, KFRAME, 5, 6, true, 0xFF, 0xFF, 0xFF);
	pie = loadTexture(piestarPath, PFRAME, 3, 4, true, 0xFF, 0xFF, 0xFF);
	sponge = loadTexture(spongePath, SFRAME, 3, 4, true, 0xFF, 0xFF, 0xFF);
	*/
	//ch01 = loadTexture(ch01Path, CH01_FRAME, 4, 4, true, 0xFF, 0xFF, 0xFF);
	ch01 = loadTexture(ch01Path, CH01_FRAME, 4, 4, true, NULL, NULL, NULL);
	rob = loadTexture(imgPath2, 1, 1, 1, false, 0xFF, 0xFF, 0xFF);


	SDL_TimerID timerID_ku = SDL_AddTimer(150, aniAction, &animationIndex);

	//Main loop flag
	bool quit = false;

	//Event handler
	SDL_Event e;		

	//While application is running
	while (!quit)
	{
		//Handle events on queue
		while (SDL_PollEvent(&e) != 0)
		{
			//User requests quit
			if (e.type == SDL_QUIT)
			{
				quit = true;
			}

			// Handle input for the dot
			handleEvent(e);
		}
				

		// Clear screen
		SDL_SetRenderDrawColor(renderer, 0, 0, 0, 0xFF);
		SDL_RenderClear(renderer);
		/*
		imgRender(renderer, rob, 0, 0, 0);		
		imgRender(renderer, sp, WIDTH / 2 - sp.width / 2, 100, 0);
				
		imgRender(renderer, kiss, 0, 300, animationIndex[0]);
		imgRender(renderer, pie, 250, 300, animationIndex[1]);
		//imgRender(renderer, sponge, 500, 300, animationIndex[2]);
		*/
		imgRender(renderer, rob, 0, 0, 0);

		move();
		//imgRender(renderer, ch01, CH01_POSX + (CH01_WIDTH - ch01.width) / 2, CH01_POSY + (CH01_HEIGHT - ch01.height) / 2, animationIndex[2]);
		imgRender(renderer, ch01, CH01_POSX, CH01_POSY, animationIndex[2]);


		// Update screen
		SDL_RenderPresent(renderer);
	}

	//Free resources and close SDL
	closeSDL();

	return 0;
}