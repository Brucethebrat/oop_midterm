/* Alphar: 2020.04.19 */

#include <stdio.h>
#include <stdlib.h>
#include <SDL.h> // Using SDL
#include "SDL2_gfxPrimitives.h" // Using SDL2_gfx
#include "SDL_image.h"  // Using SDL2 image extension library 

//Screen dimension constants
const int WIDTH = 750;
const int HEIGHT = 500;
const int CH01_FRAME = 16;
const int BLOCKNUM = 3;

const int VELOCITY = 5;
const int CH01_WIDTH = 50;
const int CH01_HEIGHT = 100;

//Initialize the velocity, position and direction
int CH01_VELX = 0;
int CH01_VELY = 0;
int CH01_POSX = 0;	//WIDTH / 2;
int CH01_POSY = 0;	//HEIGHT / 2;
int DIRECTION = 0;	//0: face downward, 1: face left, 2: face right, 3: face upward
//int DISTANCE = 0;	//when moving, if DISTANCE hasn't reach 50, then keep walking

//when true, timer run, when false, timer stop, used in handle event, when moving: true, stop: false
bool TIMER_SWITCH = false;


/*
struct ImageData
{
	char path[100];
	SDL_Texture *texture;
	int width;
	int height;
};
*/

struct ImageData
{
	char path[100];
	SDL_Texture *texture;
	int width;
	int height;
	int num;
	int wn;
	int hn;
};

int initSDL(); // Starts up SDL and creates window
void closeSDL(); // Frees media and shuts down SDL

//ImageData loadTexture(char *path, bool ckEnable, Uint8 r, Uint8 g, Uint8 b);
ImageData loadTexture(char *path, int num, int hn, int wn, bool ckEnable, Uint8 r, Uint8 g, Uint8 b);
//void imgRender(SDL_Renderer *renderer, ImageData img, int posX, int posY);
void imgRender(SDL_Renderer *renderer, ImageData img, int posX, int posY, int frame);
Uint32 aniAction(Uint32 interval, void* param); // Timer callback function
void handleEvent(SDL_Event& e);
void move();
void show_map(FILE **map_default, ImageData blocks[BLOCKNUM]);


SDL_Window *window = NULL; // The window we'll be rendering to
SDL_Renderer *renderer = NULL; // The window renderer

// Current displayed texture
SDL_Texture *bkTexture = NULL;
SDL_Texture *pikaTexture = NULL;
SDL_Texture *spTexture = NULL;


int initSDL()
{
	// Initialize SDL	
	if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_TIMER) != 0)
	{
		// Error Handling		
		printf("SDL_Init failed: %s\n", SDL_GetError());
		return 1;
	}

	// Create window	
	// SDL_WINDOWPOS_UNDEFINED: Used to indicate that you don't care what the window position is.
	window = SDL_CreateWindow("OOP SDL Tutorial", 50, 50, WIDTH, HEIGHT, SDL_WINDOW_SHOWN);
	if (window == NULL)
	{
		printf("SDL_CreateWindow failed: %s\n", SDL_GetError());
		SDL_Quit();
		return 2;
	}

	// Initialize PNG loading	
	int imgFlags = IMG_INIT_PNG;
	if (!(IMG_Init(imgFlags) & imgFlags))
	{
		printf("SDL_image failed: %s\n", IMG_GetError());
		return 3;
	}

	// Create renderer	
	// VSync allows the rendering to update at the same time as when your monitor updates during vertical refresh.
	// For this tutorial it will make sure the animation doesn't run too fast. 
	// Most monitors run at about 60 frames per second and that's the assumption we're making here. 
	// If you have a different monitor refresh rate, that would explain why the animation is running too fast or slow.
	renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC);
	if (renderer == NULL)
	{
		SDL_DestroyWindow(window);
		printf("SDL_CreateRenderer failed: %s\n", SDL_GetError());
		SDL_Quit();
		return 3;
	}

	return 0;
}


void closeSDL()
{
	// Free loaded image
	SDL_DestroyTexture(bkTexture);
	SDL_DestroyTexture(pikaTexture);

	// Destroy renderer	
	// Destroy window	
	// Quit Image subsystem
	// Quit SDL subsystems
	SDL_DestroyRenderer(renderer);
	SDL_DestroyWindow(window);
	IMG_Quit();
	SDL_Quit();
}


// ImageData loadTexture(char *path, bool ckEnable, Uint8 r, Uint8 g, Uint8 b)
ImageData loadTexture(char *path, int num, int hn, int wn, bool ckEnable, Uint8 r, Uint8 g, Uint8 b)
{
	ImageData img;


	//Load image at specified path
	SDL_Surface* loadedSurface = IMG_Load(path);
	if (loadedSurface == NULL)
	{
		printf("IMG_Load failed: %s\n", IMG_GetError());
	}
	else
	{
		// Set the color key (transparent pixel) in a surface.
		// https://wiki.libsdl.org/SDL_SetColorKey
		// The color key defines a pixel value that will be treated as transparent in a blit. 
		// It is a pixel of the format used by the surface, as generated by SDL_MapRGB().
		// Use SDL_MapRGB() to map an RGB triple to an opaque pixel value for a given pixel format.
		// https://wiki.libsdl.org/SDL_MapRGB
		SDL_SetColorKey(loadedSurface, ckEnable, SDL_MapRGB(loadedSurface->format, r, g, b));

		// Create texture from surface pixels
		img.texture = SDL_CreateTextureFromSurface(renderer, loadedSurface);
		if (img.texture == NULL)
		{
			printf("SDL_CreateTextureFromSurface failed: %s\n", SDL_GetError());
		}

		/******************************************************************/
		//Get image dimensions and information
		img.width = loadedSurface->w;
		img.height = loadedSurface->h;
		img.num = num;
		img.wn = wn;
		img.hn = hn;
		/******************************************************************/

		// Get rid of old loaded surface
		SDL_FreeSurface(loadedSurface);
	}

	//return newTexture;
	return img;
}

/*
void imgRender(SDL_Renderer *renderer, ImageData img, int posX, int posY)
{
	SDL_Rect r;
	r.x = posX;
	r.y = posY;
	r.w = img.width;
	r.h = img.height;
	SDL_RenderCopy(renderer, img.texture, NULL, &r);
}
*/

void imgRender(SDL_Renderer *renderer, ImageData img, int posX, int posY, int frame)
{
	int wc = frame % img.wn;
	int hc = frame / img.wn;
	
	SDL_Rect src, dst;
	src.x = img.width / img.wn * wc;
	src.y = img.height / img.hn * hc;
	src.w = img.width / img.wn;
	src.h = img.height / img.hn;
	dst.x = posX;
	dst.y = posY;
	dst.w = src.w;
	dst.h = src.h;

	SDL_RenderCopy(renderer, img.texture, &src, &dst);
}


Uint32 aniAction(Uint32 interval, void *param)
{
	int *index = (int *)param;
	printf("switch in timer = %d\n", TIMER_SWITCH);
	if (TIMER_SWITCH) {
		//index[1] = (index[1] + 1) % PFRAME;
		//index[2] = (index[2] + 1) % SFRAME;
		index[2] = (index[2] + 1) % (CH01_FRAME / 4) + DIRECTION * 4;
		printf("index[2] = %d", index[2]);
		printf("direction = %d", DIRECTION);

		return interval;
	}

	else {
		index[2] = 0 + DIRECTION * 4;
		return interval;
	}	
}


void handleEvent(SDL_Event& e)
{
	/* The method for "Debunce"(反彈跳時間) */

	// If a key was pressed
	// repeat: non-zero if this is a key repeat
	// https://wiki.libsdl.org/SDL_KeyboardEvent
	//if (e.type == SDL_KEYDOWN)
	if (e.type == SDL_KEYDOWN && e.key.repeat == 0)
	{
		
		//Adjust the velocity
		switch (e.key.keysym.sym)
		{
			case SDLK_UP:
				//if ((CH01_POSY <= 0) || (CH01_POSY + CH01_HEIGHT >= HEIGHT)) //53 是CH01的實際高度，留一點空間在CH01與底部之間
				//	TIMER_SWITCH = false; break;
				TIMER_SWITCH = true;
				CH01_VELY -= VELOCITY; 
				DIRECTION = 3;
				//printf("uping SWITCH = %d\n", TIMER_SWITCH);
				break; 
			case SDLK_DOWN: 
				//if ((CH01_POSY <= 0) || (CH01_POSY + CH01_HEIGHT >= HEIGHT)) //53 是CH01的實際高度，留一點空間在CH01與底部之間
				//	TIMER_SWITCH = false; break;
				TIMER_SWITCH = true;
				CH01_VELY += VELOCITY;
				DIRECTION = 0;
				break;
			case SDLK_LEFT:
				TIMER_SWITCH = true;
				CH01_VELX -= VELOCITY; 
				DIRECTION = 1;
				break;
			case SDLK_RIGHT:
				TIMER_SWITCH = true;
				CH01_VELX += VELOCITY; 
				DIRECTION = 2;
				break;
		}
	}
	//If a key was released
	//else if (e.type == SDL_KEYUP)
	else if (e.type == SDL_KEYUP && e.key.repeat == 0)
	{
		//Adjust the velocity
		switch (e.key.keysym.sym)
		{
			case SDLK_UP: TIMER_SWITCH = false; CH01_VELY += VELOCITY; break;
			case SDLK_DOWN: TIMER_SWITCH = false; CH01_VELY -= VELOCITY; break;
			case SDLK_LEFT: TIMER_SWITCH = false; CH01_VELX += VELOCITY; break;
			case SDLK_RIGHT: TIMER_SWITCH = false; CH01_VELX -= VELOCITY; break;
		}
	}
}


void move()
{
	//Move the dot left or right
	CH01_POSX += CH01_VELX;

	//If the dot went too far to the left or right
	if ((CH01_POSX < 0) || (CH01_POSX + CH01_WIDTH > WIDTH))//2 是為了留一點空間給左邊的牆壁
	{
		//Move back
		CH01_POSX -= CH01_VELX;
	}

	//Move the dot up or down
	CH01_POSY += CH01_VELY;

	//If the dot went too far up or down
	if ((CH01_POSY < 0) || (CH01_POSY + CH01_HEIGHT > HEIGHT)) //53 是CH01的實際高度，留一點空間在CH01與底部之間
	{
		//Move back
		CH01_POSY -= CH01_VELY;
	}
	if (!TIMER_SWITCH && CH01_POSY % 50 != 0) {
		if (DIRECTION == 0)
			CH01_POSY += VELOCITY;
		else if (DIRECTION == 3)
			CH01_POSY -= VELOCITY;
	}
	if (!TIMER_SWITCH && CH01_POSX % 50 != 0) {
		if (DIRECTION == 1)
			CH01_POSX -= VELOCITY;
		else if (DIRECTION == 2)
			CH01_POSX += VELOCITY;
	}
}

///*
void show_map(char matrix[10][15], ImageData blocks[BLOCKNUM]) {
	int bg;
	int i = -50;
	int j = 0;

	for (int j = 0; j < 10; j++)
		for (int i = 0; i < 15; i++) {
			if (matrix[j][i] == '1') {
				imgRender(renderer, blocks[0], i * 50, j * 50, 0);
				//printf("put floor:(%d,%d)\t",i,j);
				//printf("put floor");
			}
			else if (matrix[j][i] == '2') {
				imgRender(renderer, blocks[1], i * 50, j * 50, 0);
				//printf("put wall");
			}
			else if (matrix[j][i] == '3') {
				imgRender(renderer, blocks[2], i * 50, j * 50, 0);
				//printf("put door");
			}
		}
	//SDL_RenderPresent(renderer);
}
//*/
/*
void show_map(SDL_Renderer *renderer, FILE **map_default, ImageData blocks[BLOCKNUM]) {
	char bg;
	int i = -50;
	int j = 0;
	SDL_Rect src, dst;

	while ((bg = fgetc(*map_default)) != EOF) {
		printf("%c\t", bg);
		if (bg != (' ') && bg != '\n') {
			i += 50;
			if (i >= WIDTH)	j += 50, i = 0;
			//printf("(%d, %d) = %c\n", i, j, bg);
		}
		if (bg == '1') {
			//imgRender(renderer, blocks[0], i, j, 0);
			src.x = 0;
			src.y = 0;
			src.w = blocks[0].width;
			src.h = blocks[0].height;
			dst.x = i;
			dst.y = j;
			dst.w = src.w;
			dst.h = src.h;
			SDL_RenderCopy(renderer, blocks[0].texture, &src, &dst);

			//printf("put floor:(%d,%d)\t",i,j);
			printf("put floor");
		}
		else if (bg == '2') {
			//imgRender(renderer, blocks[1], i, j, 0);
			src.x = 0;
			src.y = 0;
			src.w = blocks[1].width;
			src.h = blocks[1].height;
			dst.x = i;
			dst.y = j;
			dst.w = src.w;
			dst.h = src.h;
			SDL_RenderCopy(renderer, blocks[1].texture, &src, &dst);
			printf("put wall");
		}
		else if (bg == '3') {
			//imgRender(renderer, blocks[2], i, j, 0);
			src.x = 0;
			src.y = 0;
			src.w = blocks[2].width;
			src.h = blocks[2].height;
			dst.x = i;
			dst.y = j;
			dst.w = src.w;
			dst.h = src.h;
			SDL_RenderCopy(renderer, blocks[2].texture, &src, &dst);
			printf("put door");
		}
	}
}
*/


// When using SDL, you have to use "int main(int argc, char* args[])"
// int main() and void main() are not allowed
int main(int argc, char* args[])
{
	// The working directory is where the vcxproj file is located.
	/*
	char imgPath1[100] = "../images/sp.png";
	char imgPath2[100] = "../images/rob.png";  
		  
	char kissPath[100] = "../images/kiss.png";
	char piestarPath[100] = "../images/piestar.png";	
	char spongePath[100] = "../images/spongebob.png";
	*/
	//主角
	char ch01Path[100] = "../images/character01_pictures_37x53.png";
	int animationIndex[3] = { 0,0,0 };
	
	//map
	/*
	char floor_path[100] = "../images/floor.jpg";
	char wall_path[100] = "../images/wall.jpg";
	char door_path[100] = "../images/door.jpg";
	*/
	//make blocks in an array, easier to pass to function
	char block_paths[BLOCKNUM][100] = { "../images/floor.jpg", "../images/wall.jpg", "../images/door.jpg" };
	char map_path[100] = "../map/default.txt";


	ImageData ch01;//, sponge, kiss, pie;
	//ImageData floor, wall, door;
	ImageData blocks[BLOCKNUM];


	// Start up SDL and create window
	if (initSDL())
	{
		printf("Failed to initialize SDL!\n");
		return -1;
	}

	/*
	sp = loadTexture(imgPath1, 1, 1, 1, true, 0xFF, 0xFF, 0xFF);
	rob = loadTexture(imgPath2, 1, 1, 1, false, 0xFF, 0xFF, 0xFF);
	
	kiss = loadTexture(kissPath, KFRAME, 5, 6, true, 0xFF, 0xFF, 0xFF);
	pie = loadTexture(piestarPath, PFRAME, 3, 4, true, 0xFF, 0xFF, 0xFF);
	sponge = loadTexture(spongePath, SFRAME, 3, 4, true, 0xFF, 0xFF, 0xFF);
	*/
	//ch01 = loadTexture(ch01Path, CH01_FRAME, 4, 4, true, 0xFF, 0xFF, 0xFF);
	ch01 = loadTexture(ch01Path, CH01_FRAME, 4, 4, false, NULL, NULL, NULL);
	/*
	floor = loadTexture(floor_path, 1, 1, 1, false, 0xFF, 0xFF, 0xFF);
	wall = loadTexture(wall_path, 1, 1, 1, false, 0xFF, 0xFF, 0xFF);
	door = loadTexture(door_path, 1, 1, 1, false, 0xFF, 0xFF, 0xFF);
	*/
	for (int x = 0; x < 3; x++) {
		blocks[x] = loadTexture(block_paths[x], 1, 1, 1, false, 0xFF, 0xFF, 0xFF);
	}


	FILE *map_default;
	errno_t err;
	err = fopen_s(&map_default, map_path, "r");
	if (map_default == NULL) {
		printf("fail to open map");
		return 1;
	}
	int i = 0, j = 0;
	char bg;
	char map_array[10][15];	// since reading the file only read once, so we need an matrix to save the data
	while ((bg = fgetc(map_default)) != EOF) {
		if (bg != ' ' && bg != '\n') {
			map_array[i][j] = bg;
			j++;
		}
		else if (bg == '\n') {
			i++; 
			j = 0;
		}
		else{}
	}


	SDL_TimerID timerID_ku = SDL_AddTimer(150, aniAction, &animationIndex);

	//Main loop flag
	bool quit = false;

	//Event handler
	SDL_Event e;		

	//While application is running
	while (!quit)
	{
		//Handle events on queue
		while (SDL_PollEvent(&e) != 0)
		{
			//User requests quit
			if (e.type == SDL_QUIT)
			{
				quit = true;
			}

			// Handle input for the CH01
			handleEvent(e);
		}
				

		// Clear screen
		SDL_SetRenderDrawColor(renderer, 0, 0, 0, 0xFF);
		SDL_RenderClear(renderer);
		/*
		imgRender(renderer, rob, 0, 0, 0);		
		imgRender(renderer, sp, WIDTH / 2 - sp.width / 2, 100, 0);
				
		imgRender(renderer, kiss, 0, 300, animationIndex[0]);
		imgRender(renderer, pie, 250, 300, animationIndex[1]);
		//imgRender(renderer, sponge, 500, 300, animationIndex[2]);
		*/
		//show map
		//show_map(renderer, &map_default, blocks);
		show_map(map_array, blocks);
		//imgRender(renderer, blocks[0], 50, 50, 0);

		move();
		//imgRender(renderer, ch01, CH01_POSX + (CH01_WIDTH - ch01.width) / 2, CH01_POSY + (CH01_HEIGHT - ch01.height) / 2, animationIndex[2]);
		imgRender(renderer, ch01, CH01_POSX + (CH01_WIDTH - ch01.width / 4) / 2, CH01_POSY + (CH01_HEIGHT - ch01.height / 4) / 4 * 3, animationIndex[2]);
		//printf("CH01_WIDTH = %d, ch01.width = %d\n", CH01_WIDTH, ch01.width);
		//printf("CH01_HEIGHT = %d, ch01.height = %d\n", CH01_HEIGHT, ch01.height);

		// Update screen
		SDL_RenderPresent(renderer);
	}

	//Free resources and close SDL
	closeSDL();
	//close file
	fclose(map_default);

	return 0;
}